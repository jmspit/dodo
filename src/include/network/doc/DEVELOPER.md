# Networking {#developer_networking}

## Asymmetric cryptography

In asymmetric cryptography, each endpoint (either a sender or a recipient) has a private-public keypair.

  - The private key is generated by and remains secret of its owner (and can be protected with a passphrase).
  - Each private key has a unique public key (the public information bits are part of the private key).
  - A private key decrypts, a public key encrypts (so the keys are asymmetrical).
  - Only the private key can decrypt data encrypted with its public key.

![Public key infrastructure](/home/spjm/projects/dodo/src/include/network/doc/asymmetric_key_encryption.svg)

If Bob receives a public key, say during a connection handshake, how does Bob prove the public key
belongs to Alice?

## Transport Layer Security

TLS provides communication security

  - The connection is private.
  - The identity of the peer can be verified.
  - The connection is reliable as a transmit includes an integretiy check.

During TLS handshake, both peers apply their key pairs asymetrically to negotiate a symmetric session key, used
to both encrypt and decrypt data.

In TLS the following artefact types are used

  - The private key.
  - A certificate signing request (CSR) which is a X.509 document typically stored as a PEM file, and comprises
    - the public key
    - data describing the owner
  - A public key certificate (PKC), which is a X.509 document typically stored as a PEM file, and comrpises
    - the public key as in the CSR.
    - data describing the owner as in the CSR.
    - The digital signature of a CA.

The Certificate Authority (CA) signs a CSR into a PKC by writing a digital signature into it - after verifying the onwer
of the public key (and thus the owner of the private key) is acurately described by the data in the CSR
(the FQDN belongs to the owner of the public key). The dodo::network::X509Certificate class encapsulates CSR
and PKC documents.

The context of a TLS connection is encapsulated by the dodo::network::TLSContext class. The same TLSContext can
be used by multiple dodo::network::TLSSocket classes.

TLS evolved protocol versions, and version 1.0 is deprecated (as are its predecessors, SSLv2 and SSLv3).

  - TLS 1.0 : Deprecated and not supported
  - TLS 1.1 : Deprecated but supported (dodo::network::TLSContext::TLSVersion::tls1_1)
  - TLS 1.2 : Common (dodo::network::TLSContext::TLSVersion::tls1_2)
  - TLS 1.3 : Best (dodo::network::TLSContext::TLSVersion::tls1_3 == dodo::network::TLSContext::TLSVersion::tlsBest)

In order to verify a peer, there are options

  - dodo::network::TLSContext::PeerVerification::pvNone - Use no peer verification. The connection is private, but
    information is shared with an unknown identity (like a man in the middle or a woman at the end).
  - dodo::network::TLSContext::PeerVerification::pvCA - Use the default mechanism where the CA truststore is used to
    verify the peer owns the peer Common Name (CN) aka peer FQDN. The connection is private, aand the remote
    identity assured.
  - dodo::network::TLSContext::PeerVerification::pvCustom - The developer provides his own verification of the peer
    certificate - based on its signed contents.

### Public key infrastructure

The internet has a PKI for websites, or in general things with a fqdn properly registered in DNS. In order to get
a certificate signed into that domain one has to send a *Certificate Signing Request* (CSR) to a
*Certification Authority* (CA). A trusted CA is a private key that has a public certificate in the system truststore,
or a custom truststore. A CA has peer-verification authority.


#### Setup Certification Authority

As an example, we setup a private trust network by using a

#### Server

Generate a 4096 bit RSA private key with des3 passphrase encryption

```bash
$ openssl genpkey -algorithm RSA -out server.key -pkeyopt rsa_keygen_bits:4096 -des3
$ chmod 600 server.key
$ openssl rsa -in server.key -check
```

the public bits are part of the private key, so the public key can be generated from the private key

```bash
$ openssl rsa -in server.key -outform PEM -pubout -out server.pub
$ head -2 server.pub
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuFvk6gTCnykpLrAhFLPM
```

the public key must have a header as above - verify you are not accidentally storing pivate in a file named public
(which would happen if the `-pubout` was omitted).

Generate a Certificate Signing Request (CSR) from the private key. The CSR is not a secret, and can be signed by a CA
if it has verified the CN owns the private key that generated the CSR.

Note that the challenge password is visible to those with access to a copy of the CSR - the challange password is just
a weak shared secret so that the receiver of a CSR can challenge it.

```bash
$ openssl req -new -key server.key -out server_csr.pem
$ openssl req -text -noout -verify -in server_csr.pem
```

#### Client

```bash
$ openssl genpkey -algorithm RSA -out client.key -pkeyopt rsa_keygen_bits:4096 -des3
$ chmod 600 client.key
$ openssl rsa -in client.key -check
```

```bash
$ openssl rsa -in client.key -outform PEM -pubout -out client.pub
$ head -2 client.pub
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuFvk6gTCnykpLrAhFLPM
```

```bash
$ openssl req -new -key client.key -out client_csr.pem
$ openssl req -text -noout -verify -in client_csr.pem
```


